#!/usr/bin/perl
#
# unzip-k - extract a ZIP archive containing file or directory name
# encoded in Microsoft's CP949
#
# unzip-k will extract compressed files from a ZIP archive containing
# file or directory name encoded in Microsoft's CP949.
#
# This program requires Archive::Zip and Text::Glob modules. In
# Ubuntu, you may need to install libarchive-zip-perl and
# libtext-glob-perl package.
#
# http://ubuntu.or.kr/viewtopic.php?f=4&t=13970
#
# Seungwon Jeong <seungwon0@gmail.com>
#
# Copyright (C) 2010 by Seungwon Jeong

use strict;

use warnings;

use Archive::Zip qw( :ERROR_CODES :CONSTANTS );

use Encode;

use Getopt::Long;

use Text::Glob qw( match_glob );
$Text::Glob::strict_wildcard_slash = 0;

use File::Spec;

my @xfiles;
my $exdir;
my $crt;

# TODO: Support -l, -p, -t and -z options
# TODO: Support -C, -j, -n, -o, -q, -s and -W modifiers
GetOptions(
    'x=s{,}' => \@xfiles,
    'd=s'    => \$exdir,
    'c'	     => \$crt,
);

if (@ARGV < 1) {
    print_usage();
    exit;
}

my ($file, @files) = @ARGV;

ARCHIVE:
for my $archive ($file, "$file.zip", "$file.ZIP") {
    next ARCHIVE if ! -f $archive;
    extract_archive($archive,
		    {
			files  => \@files,
			xfiles => \@xfiles,
			exdir  => $exdir,
			crt    => $crt,
		    })
	and exit;
}

die "unzip-k:  cannot find or open $file, $file.zip or $file.ZIP.\n";

sub print_usage {
    print <<'END_USAGE';
UnZip-K 0.3 of 24 November 2010, by Seungwon Jeong.

Usage: unzip-k file[.zip] [file(s) ...] [-x xfile(s) ...] [-d exdir]
  Default action is to extract files in list, except those in xlist, to exdir.

  -x  exclude files that follow (in xlist)   -d  extract files into exdir
Examples:
  unzip data1 -x joe   => extract all files except joe from zipfile data1.zip
END_USAGE
    return;
}

sub extract_archive {
    my ($archive_name, $arg_ref) = @_;
    my $files_ref  = $arg_ref->{files};
    my $xfiles_ref = $arg_ref->{xfiles};
    my $exdir	   = $arg_ref->{exdir};
    my $crt	   = $arg_ref->{crt};

    print "Archive:  $archive_name\n";

    my $zip = Archive::Zip->new();

    $zip->read($archive_name) == AZ_OK or return;

    my %file_is_matched;
    my %xfile_is_matched;

    my $replace;

  MEMBER:
    for my $member ($zip->members()) {
	my $member_name = decode_name_of($member);

	# Check archive members to be excluded from processing
	if (@{$xfiles_ref}) {
	    for my $xfile (@{$xfiles_ref}) {
		if (match_glob($xfile, $member_name)) {
		    $xfile_is_matched{$xfile} = 1;
		    next MEMBER;
		}
	    }
	}

	if (@{$files_ref}) {
	    # Check archive members to be processed
	    for my $file (@{$files_ref}) {
		if (match_glob($file, $member_name)) {
		    $file_is_matched{$file} = 1;
		    extract_member($member,
				   {
				       replace => \$replace,
				       exdir   => $exdir,
				       crt     => $crt,
				   });
		}
	    }
	}
	else {
	    extract_member($member,
			   {
			       replace => \$replace,
			       exdir   => $exdir,
			       crt     => $crt,
			   });
	}
    }

    # print caution about unmatched filenames
    for my $file (grep { ! $file_is_matched{$_} } @{$files_ref}) {
	print "caution: filename not matched_files:  $file\n";
    }
    for my $xfile (grep { ! $xfile_is_matched{$_} } @{$xfiles_ref}) {
	print "caution: excluded filename not matched_files:  $xfile\n";
    }

    return 1;
}

sub extract_member {
    my ($member, $arg_ref) = @_;
    my $replace_ref = $arg_ref->{replace};
    my $exdir	    = $arg_ref->{exdir};
    my $crt         = $arg_ref->{crt};

    # Get file name to be extracted
    my $extracted_name = decode_name_of($member);
    if (defined $exdir && $exdir ne q{}) {
	$extracted_name = File::Spec->catfile($exdir, $extracted_name);
    }

    # Check existing file or directory
  CHECK:
    while (!$crt && -e $extracted_name) {
	return if defined ${$replace_ref} && ${$replace_ref} eq 'None';

	return if -d $extracted_name && $member->isDirectory();

	last CHECK if defined ${$replace_ref} && ${$replace_ref} eq 'All';

	my $response = get_response_for($extracted_name);
	if ($response eq 'yes') {
	    last CHECK;
	}
	elsif ($response eq 'no') {
	    return;
	}
	elsif ($response eq 'All') {
	    ${$replace_ref} = 'All';
	    last CHECK;
	}
	elsif ($response eq 'None') {
	    ${$replace_ref} = 'None';
	    return;
	}
	elsif ($response eq 'rename') {
	    $extracted_name = get_new_name();
	}
	else {
	    warn "invalid response!\n";
	}
    }

    print_progress_using($member, $extracted_name);

    if ($crt) {
	my ($contents, $status) = $member->contents();
	if ($status == AZ_OK) {
	    print $contents, "\n";
	}
	else {
	    warn "extract error!\n";
	}
    }
    else {
	$member->extractToFileNamed($extracted_name) == AZ_OK
	    or warn "extract error!\n";
    }

    return;
}

sub decode_name_of {
    my ($member) = @_;

    # CP949 -> UTF-8
    my $ENCODING = 'cp949';
    return encode_utf8(decode($ENCODING, $member->fileName()));
}

sub get_response_for {
    my ($extracted_name) = @_;

    my %pattern_for = (
	yes    => qr{^y}xms,
	no     => qr{^n}xms,
	All    => qr{^A}xms,
	None   => qr{^N}xms,
	rename => qr{^r}xms,
    );

  RESPONSE:
    while (1) {
	print "replace $extracted_name? "
	    . "[y]es, [n]o, [A]ll, [N]one, [r]ename: "
	    ;

	my $response = <STDIN>;
	if (! defined $response) {
	    print qq{\n(EOF or read error, treating as "[N]one" ...)\n};
	    return 'None';
	}

	chomp $response;
	if ($response =~ $pattern_for{yes}) {
	    return 'yes';
	}
	elsif ($response =~ $pattern_for{no}) {
	    return 'no';
	}
	elsif ($response =~ $pattern_for{All}) {
	    return 'All'
	}
	elsif ($response =~ $pattern_for{None}) {
	    return 'None';
	}
	elsif ($response =~ $pattern_for{rename}) {
	    return 'rename';
	}
	else {
	    if ($response eq q{}) {
		warn "error:  invalid response [{ENTER}]\n";
	    }
	    else {
		warn "error:  invalid response [$response]\n";
	    }
	    next RESPONSE;
	}
    }

    return;
}

sub get_new_name {
    my $new_name;

  NAME:
    while (1) {
	print 'new name: ';

	$new_name = <STDIN>;
	next NAME if ! defined $new_name;

	chomp $new_name;
	last NAME if $new_name ne q{};
    }

    return $new_name;
}

sub print_progress_using {
    my ($member, $extracted_name) = @_;

    if ($member->isDirectory()) {
	print "  creating: $extracted_name\n";
    }
    elsif ($member->desiredCompressionMethod() == COMPRESSION_STORED) {
	print " extracting: $extracted_name\n";
    }
    else {
	print "  inflating: $extracted_name\n";
    }

    return;
}

__END__

=head1 NAME

unzip-k - extract a ZIP archive containing file or directory name
encoded in Microsoft's CP949


=head1 SYNOPSIS

B<unzip-k> F<file>[F<.zip>] [F<file(s)>] [-x F<xfile(s)> ...] [-d F<exdir>]


=head1 DESCRIPTION

I<unzip-k> will extract compressed files from a ZIP archive containing
file or directory name encoded in Microsoft's CP949. The default
behavior (with no options) is to extract into the current directory
(and subdirectories below it) all files from the specified ZIP
archive.  A companion program, zip(1), creates ZIP archives; both
programs are compatible with archives created by PKWARE's PKZIP and
PKUNZIP for MS-DOS, but in many cases the program options or default
behaviors differ.


=head1 ARGUMENTS

=over

=item F<file>[F<.zip>]

Path of the ZIP archive.

=item [F<file(s)>]

An optional list of archive members to be processed, separated by
spaces.  Regular expressions (wildcards) may be used to match multiple
members.  Be sure to quote expressions that would otherwise be
expanded or modified by the operating system.

=item [-x F<file(s)>]

An optional list of archive members to be excluded from processing.
Since wildcard characters normally match (`/') directory separators,
this option may be used to exclude any files that are in
subdirectories.  For example, ``unzip foo *.[ch] -x */*'' would
extract all C source files in the main directory, but none in any
subdirectories.  Without the -x option, all C source files in all
directories within the zipfile would be extracted.

=item [-d F<exdir>]

An optional directory to which to extract files.  By default, all
files and subdirectories are recreated in the current direc‐ tory; the
-d option allows extraction in an arbitrary directory (always assuming
one has permission to write to the directory).  This option need not
appear at the end of the command line; it is also accepted before the
zipfile specification (with the nor‐ mal options), immediately after
the zipfile specification, or between the file(s) and the -x option.
The option and directory may be concatenated without any white space
between them, but note that this may cause normal shell behavior to be
suppressed.  In particular, ``-d ~'' (tilde) is expanded by Unix C
shells into the name of the user's home directory, but ``-d~'' is
treated as a literal subdirectory ``~'' of the current direc‐ tory.

=back


=head1 OPTIONS

=over

=item B<-c>

extract files to stdout/screen (``CRT'').  This option is similar to
the -p option except that the name of each file is printed as it is
extracted.  This option is not listed in the unzip-k usage screen.

=back


=head1 EXAMPLES

To use unzip to extract all members of the archive letters.zip into
the current directory and subdirectories below it, creating any
subdirectories as necessary:

unzip letters

To extract all FORTRAN and C source files--*.f, *.c, *.h, and
Makefile--into the /tmp directory:

unzip source.zip "*.[fch]" Makefile -d /tmp

(the double quotes are necessary only in Unix and only if globbing is
turned on).


=head1 DEPENDENCIES

=over

=item C<Archive::Zip>

=item C<Encode>

=item C<Text::Glob>

=item C<Getopt::Long>

=item C<File::Spec>

=back


=head1 URL

https://github.com/seungwon0/unzip-k


=head1 AUTHOR

Seungwon Jeong E<lt>seungwon0@gmail.comE<gt>


=head1 SEE ALSO

funzip(1), zip(1), unzip(1), zipcloak(1), zipgrep(1), zipinfo(1),
zipnote(1), zipsplit(1)

=cut
