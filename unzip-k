#!/usr/bin/perl
#
# unzip-k - list, test and extract a ZIP archive containing file or
# directory name encoded in Microsoft's CP949
#
# unzip-k will list, test or extract compressed files from a ZIP
# archive containing file or directory name encoded in Microsoft's
# CP949.
#
# This program requires Archive::Zip and Text::Glob modules. In
# Ubuntu, you may need to install libarchive-zip-perl and
# libtext-glob-perl package.
#
# http://ubuntu.or.kr/viewtopic.php?f=4&t=13970
#
# Seungwon Jeong <seungwon0@gmail.com>
#
# Copyright (C) 2010 by Seungwon Jeong

use strict;

use warnings;

use Archive::Zip qw( :ERROR_CODES :CONSTANTS );

use Encode;

use Getopt::Long;

use Text::Glob qw( match_glob );
$Text::Glob::strict_wildcard_slash = 0;

use File::Spec::Functions qw (catfile);

use POSIX qw( strftime );

my @xfiles;
my $exdir;
my $crt;
my $list;
my $pipe;
my $test;
my $comment;

# TODO: Support -C, -j, -n, -o, -q, -s and -W modifiers
GetOptions(
    'x=s{,}' => \@xfiles,
    'd=s'    => \$exdir,
    'c'	     => \$crt,
    'l'      => \$list,
    'p'      => \$pipe,
    't'      => \$test,
    'z'      => \$comment,
);

if (@ARGV < 1) {
    print_usage();
    exit;
}

my ($file, @files) = @ARGV;

ARCHIVE:
for my $archive ($file, "$file.zip", "$file.ZIP") {
    next ARCHIVE if ! -f $archive;
    extract_archive($archive,
		    {
			files	=> \@files,
			xfiles	=> \@xfiles,
			exdir	=> $exdir,
			crt	=> $crt,
			list	=> $list,
			pipe	=> $pipe,
			test	=> $test,
			comment => $comment,
		    })
	and exit;
}

die "unzip-k:  cannot find or open $file, $file.zip or $file.ZIP.\n";

sub print_usage {
    print <<'END_USAGE';
UnZip-K 0.4 of 24 November 2010, by Seungwon Jeong.

Usage: unzip-k [-clptz] file[.zip] [file(s) ...] [-x xfile(s) ...] [-d exdir]
  Default action is to extract files in list, except those in xlist, to exdir.

  -p  extract files to pipe, no messages     -l  list files
  -t  test compressed archive data           -z  display archive comment only
  -x  exclude files that follow (in xlist)   -d  extract files into exdir
Examples:
  unzip data1 -x joe   => extract all files except joe from zipfile data1.zip
  unzip -p foo | more  => send contents of foo.zip via pipe into program more
END_USAGE
    return;
}

sub extract_archive {
    my ($archive_name, $arg_ref) = @_;
    my $files_ref  = $arg_ref->{files};
    my $xfiles_ref = $arg_ref->{xfiles};
    my $exdir	   = $arg_ref->{exdir};
    my $crt	   = $arg_ref->{crt};
    my $list       = $arg_ref->{list};
    my $pipe       = $arg_ref->{pipe};
    my $test       = $arg_ref->{test};
    my $comment    = $arg_ref->{comment};

    if (!$pipe) {
	print "Archive:  $archive_name\n";
    }

    my $zip = Archive::Zip->new();

    $zip->read($archive_name) == AZ_OK or return;

    my %file_is_matched;
    my %xfile_is_matched;

    my $replace;

    my $total_length = 0;
    my $total_count  = 0;

    my $error;

    if ($list || $test || $comment) {
	# Print archive comment
	my $archive_comment = $zip->zipfileComment();
	if ($archive_comment ne q{}) {
	    print $archive_comment, "\n";
	}
    }

    return 1 if $comment;

    if ($list) {
	# Print list header
	print "  Length      Date    Time    Name\n";
	print "---------  ---------- -----   ----\n";
    }

  MEMBER:
    for my $member ($zip->members()) {
	my $member_name = decode_name_of($member);

	# Check archive members to be excluded from processing
	if (@{$xfiles_ref}) {
	    for my $xfile (@{$xfiles_ref}) {
		if (match_glob($xfile, $member_name)) {
		    $xfile_is_matched{$xfile} = 1;
		    next MEMBER;
		}
	    }
	}

	if (@{$files_ref}) {
	    # Check archive members to be processed
	    for my $file (@{$files_ref}) {
		if (match_glob($file, $member_name)) {
		    $file_is_matched{$file} = 1;
		    $total_length += $member->uncompressedSize();
		    $total_count++;
		    extract_member($member,
				   {
				       replace => \$replace,
				       exdir   => $exdir,
				       crt     => $crt,
				       list    => $list,
				       pipe    => $pipe,
				       test    => $test,
				       error   => \$error,
				   });
		}
	    }
	}
	else {
	    $total_length += $member->uncompressedSize();
	    $total_count++;
	    extract_member($member,
			   {
			       replace => \$replace,
			       exdir   => $exdir,
			       crt     => $crt,
			       list    => $list,
			       pipe    => $pipe,
			       test    => $test,
			       error   => \$error,
			   });
	}
    }

    if ($list) {
	# Print list footer
	print "---------                     -------\n";
	my $format = "%9u                     %u %s\n";
	printf $format,
	       $total_length, $total_count,
	       $total_count > 1 ? "files" : "file"
	       ;
    }

    # print caution about unmatched filenames
    for my $file (grep { ! $file_is_matched{$_} } @{$files_ref}) {
	print "caution: filename not matched_files:  $file\n";
    }
    for my $xfile (grep { ! $xfile_is_matched{$_} } @{$xfiles_ref}) {
	print "caution: excluded filename not matched_files:  $xfile\n";
    }

    if ($test) {
	if ($error) {
	    print "At least one error was detected in $archive_name.\n"
	}
	elsif ($total_count == 0) {
	    print "Caution:  zero files tested in $archive_name.\n";
	}
	elsif (@{$files_ref} || @{$xfiles_ref}) {
	    print "No errors detected in $archive_name"
		. " for the $total_count files tested.\n"
		;
	}
	else {
	    print "No errors detected in compressed data of $archive_name.\n";
	}
    }

    return 1;
}

sub extract_member {
    my ($member, $arg_ref) = @_;
    my $replace_ref = $arg_ref->{replace};
    my $exdir	    = $arg_ref->{exdir};
    my $crt         = $arg_ref->{crt};
    my $list        = $arg_ref->{list};
    my $pipe        = $arg_ref->{pipe};
    my $test        = $arg_ref->{test};
    my $error_ref   = $arg_ref->{error};

    # Get file name to be extracted
    my $extracted_name = decode_name_of($member);
    if (!$crt && !$list && !$pipe && defined $exdir && $exdir ne q{}) {
	$extracted_name = catfile($exdir, $extracted_name);
    }

    # Check existing file or directory
  CHECK:
    while (!$crt && !$list && !$pipe && -e $extracted_name) {
	return if defined ${$replace_ref} && ${$replace_ref} eq 'None';

	return if -d $extracted_name && $member->isDirectory();

	last CHECK if defined ${$replace_ref} && ${$replace_ref} eq 'All';

	my $response = get_response_for($extracted_name);
	if ($response eq 'yes') {
	    last CHECK;
	}
	elsif ($response eq 'no') {
	    return;
	}
	elsif ($response eq 'All') {
	    ${$replace_ref} = 'All';
	    last CHECK;
	}
	elsif ($response eq 'None') {
	    ${$replace_ref} = 'None';
	    return;
	}
	elsif ($response eq 'rename') {
	    $extracted_name = get_new_name();
	}
	else {
	    warn "invalid response!\n";
	}
    }

    if (!$list && !$pipe && !$test) {
	print_progress_using($member, $extracted_name);
    }

    if ($crt) {
	my ($contents, $status) = $member->contents();
	if ($status == AZ_OK) {
	    print $contents, "\n";
	}
	else {
	    warn "extract error!\n";
	}
    }
    elsif ($list) {
	# Print list contents
	my $format = "%9u  %s   %s\n";
	printf $format,
	       $member->uncompressedSize(),
	       strftime("%F %R", localtime $member->lastModTime()),
	       $extracted_name
	       ;

	# Print individual file comment
	my $file_comment = $member->fileComment();
	if ($file_comment ne q{}) {
	    print $file_comment, "\n";
	}
    }
    elsif ($pipe) {
	$member->extractToFileHandle(*STDOUT);
    }
    elsif ($test) {
	printf "    testing: %-22s", $extracted_name;

	my $crc32 = $member->crc32();
	my $computed_crc32 = Archive::Zip::computeCRC32($member->contents());
	if ($crc32 == $computed_crc32) {
	    print "   OK\n";
	}
	else {
	    ${$error_ref} = 1;
	    printf " bad CRC %08lx  (should be %08lx)\n",
		   $crc32, $computed_crc32
		   ;
	}
    }
    else {
	$member->extractToFileNamed($extracted_name) == AZ_OK
	    or warn "extract error!\n";
    }

    return;
}

sub decode_name_of {
    my ($member) = @_;

    # CP949 -> UTF-8
    my $ENCODING = 'cp949';
    return encode_utf8(decode($ENCODING, $member->fileName()));
}

sub get_response_for {
    my ($extracted_name) = @_;

    my %pattern_for = (
	yes    => qr{^y}xms,
	no     => qr{^n}xms,
	All    => qr{^A}xms,
	None   => qr{^N}xms,
	rename => qr{^r}xms,
    );

  RESPONSE:
    while (1) {
	print "replace $extracted_name? "
	    . "[y]es, [n]o, [A]ll, [N]one, [r]ename: "
	    ;

	my $response = <STDIN>;
	if (! defined $response) {
	    print qq{\n(EOF or read error, treating as "[N]one" ...)\n};
	    return 'None';
	}

	chomp $response;
	if ($response =~ $pattern_for{yes}) {
	    return 'yes';
	}
	elsif ($response =~ $pattern_for{no}) {
	    return 'no';
	}
	elsif ($response =~ $pattern_for{All}) {
	    return 'All'
	}
	elsif ($response =~ $pattern_for{None}) {
	    return 'None';
	}
	elsif ($response =~ $pattern_for{rename}) {
	    return 'rename';
	}
	else {
	    if ($response eq q{}) {
		warn "error:  invalid response [{ENTER}]\n";
	    }
	    else {
		warn "error:  invalid response [$response]\n";
	    }
	    next RESPONSE;
	}
    }

    return;
}

sub get_new_name {
    my $new_name;

  NAME:
    while (1) {
	print 'new name: ';

	$new_name = <STDIN>;
	next NAME if ! defined $new_name;

	chomp $new_name;
	last NAME if $new_name ne q{};
    }

    return $new_name;
}

sub print_progress_using {
    my ($member, $extracted_name) = @_;

    if ($member->isDirectory()) {
	print "  creating: $extracted_name\n";
    }
    elsif ($member->desiredCompressionMethod() == COMPRESSION_STORED) {
	print " extracting: $extracted_name\n";
    }
    else {
	print "  inflating: $extracted_name\n";
    }

    return;
}

__END__

=head1 NAME

unzip-k - list, test and extract a ZIP archive containing file or
directory name encoded in Microsoft's CP949


=head1 SYNOPSIS

B<unzip-k> [B<-clptz>] F<file>[F<.zip>] [F<file(s)>] [-x F<xfile(s)> ...] [-d F<exdir>]


=head1 DESCRIPTION

I<unzip-k> will list, test or extract compressed files from a ZIP
archive containing file or directory name encoded in Microsoft's
CP949. The default behavior (with no options) is to extract into the
current directory (and subdirectories below it) all files from the
specified ZIP archive.  A companion program, zip(1), creates ZIP
archives; both programs are compatible with archives created by
PKWARE's PKZIP and PKUNZIP for MS-DOS, but in many cases the program
options or default behaviors differ.


=head1 ARGUMENTS

=over

=item F<file>[F<.zip>]

Path of the ZIP archive.

=item [F<file(s)>]

An optional list of archive members to be processed, separated by
spaces.  Regular expressions (wildcards) may be used to match multiple
members.  Be sure to quote expressions that would otherwise be
expanded or modified by the operating system.

=item [-x F<file(s)>]

An optional list of archive members to be excluded from processing.
Since wildcard characters normally match (`/') directory separators,
this option may be used to exclude any files that are in
subdirectories.  For example, ``unzip foo *.[ch] -x */*'' would
extract all C source files in the main directory, but none in any
subdirectories.  Without the -x option, all C source files in all
directories within the zipfile would be extracted.

=item [-d F<exdir>]

An optional directory to which to extract files.  By default, all
files and subdirectories are recreated in the current direc‐ tory; the
-d option allows extraction in an arbitrary directory (always assuming
one has permission to write to the directory).  This option need not
appear at the end of the command line; it is also accepted before the
zipfile specification (with the nor‐ mal options), immediately after
the zipfile specification, or between the file(s) and the -x option.
The option and directory may be concatenated without any white space
between them, but note that this may cause normal shell behavior to be
suppressed.  In particular, ``-d ~'' (tilde) is expanded by Unix C
shells into the name of the user's home directory, but ``-d~'' is
treated as a literal subdirectory ``~'' of the current direc‐ tory.

=back


=head1 OPTIONS

=over

=item B<-c>

extract files to stdout/screen (``CRT'').  This option is similar to
the -p option except that the name of each file is printed as it is
extracted.  This option is not listed in the unzip-k usage screen.

=item B<-l>

list archive files.  The names, uncompressed file sizes and
modification dates and times of the specified files are printed, along
with totals for all files specified.  In addition, the zipfile comment
and individual file comments (if any) are displayed.

=item B<-p>

extract files to pipe (stdout).  Nothing but the file data is sent to
stdout, and the files are always extracted in binary format, just as
they are stored (no conversions).

=item B<-t>

test archive files.  This option extracts each specified file in
memory and compares the CRC (cyclic redundancy check, an enhanced
checksum) of the expanded file with the original file's stored CRC
value.

=item B<-z>

display only the archive comment.

=back


=head1 EXAMPLES

To use unzip to extract all members of the archive letters.zip into
the current directory and subdirectories below it, creating any
subdirectories as necessary:

unzip letters

To extract all FORTRAN and C source files--*.f, *.c, *.h, and
Makefile--into the /tmp directory:

unzip source.zip "*.[fch]" Makefile -d /tmp

(the double quotes are necessary only in Unix and only if globbing is
turned on).


=head1 DEPENDENCIES

=over

=item C<Archive::Zip>

=item C<Encode>

=item C<Text::Glob>

=item C<Getopt::Long>

=item C<File::Spec::Functions>

=item C<POSIX>

=back


=head1 URL

https://github.com/seungwon0/unzip-k


=head1 AUTHOR

Seungwon Jeong E<lt>seungwon0@gmail.comE<gt>


=head1 SEE ALSO

funzip(1), zip(1), unzip(1), zipcloak(1), zipgrep(1), zipinfo(1),
zipnote(1), zipsplit(1)

=cut
