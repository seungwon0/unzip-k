#!/usr/bin/perl
#
# unzip-k - extract a ZIP archive containing file or directory name
# encoded in Microsoft's CP949
#
# unzip-k will extract compressed files from a ZIP archive containing
# file or directory name encoded in Microsoft's CP949.
#
# This program requires Archive::Zip and Text::Glob modules. In
# Ubuntu, you may need to install libarchive-zip-perl and
# libtext-glob-perl package.
#
# http://ubuntu.or.kr/viewtopic.php?f=4&t=13970
#
# Seungwon Jeong <seungwon0@gmail.com>
#
# Copyright (C) 2010 by Seungwon Jeong

use strict;

use warnings;

use Archive::Zip qw( :ERROR_CODES :CONSTANTS );

use Encode;

use Getopt::Long;

use Text::Glob qw( match_glob );
$Text::Glob::strict_wildcard_slash = 0;

my @xfiles;
GetOptions('x=s{,}' => \@xfiles);

if (@ARGV < 1) {
    print_banner();
    print "\n";
    print_usage();
    exit;
}

my $file  = shift @ARGV;
my @files = @ARGV;

ARCHIVE:
for my $archive ($file, "$file.zip", "$file.ZIP") {
    next ARCHIVE if ! -f $archive;
    extract_archive($archive, \@files, \@xfiles) and exit;
}

die "unzip-k:  cannot find or open $file, $file.zip or $file.ZIP.\n";

sub print_banner {
    print "UnZip-K 0.3 November 2010, by Seungwon Jeong.\n";
    return;
}

sub print_usage {
    print "Usage: unzip-k file[.zip] [file(s) ...] [-x xfile(s) ...]\n";
    return;
}

sub extract_archive {
    my ($archive_name, $files_ref, $xfiles_ref) = @_;

    print "Archive:  $archive_name\n";

    my $zip = Archive::Zip->new();

    $zip->read($archive_name) == AZ_OK or return;

    my %matched_files  = map { $_ => 0 } @{$files_ref};
    my %matched_xfiles = map { $_ => 0 } @{$xfiles_ref};

    my $replace;

  MEMBER:
    for my $member ($zip->members()) {
	my $member_name = decode_name_of($member);

	# Check archive members to be excluded from processing
	if (@{$xfiles_ref}) {
	    for my $xfile (@{$xfiles_ref}) {
		if (match_glob($xfile, $member_name)) {
		    $matched_xfiles{$xfile} = 1;
		    next MEMBER;
		}
	    }
	}

	if (@{$files_ref}) {
	    # Check archive members to be processed
	    for my $file (@{$files_ref}) {
		if (match_glob($file, $member_name)) {
		    $matched_files{$file} = 1;
		    extract_member($member, \$replace);
		}
	    }
	}
	else {
	    extract_member($member, \$replace);
	}
    }

    # print caution about unmatched filenames
    for my $file (grep { ! $matched_files{$_} } @{$files_ref}) {
	print "caution: filename not matched_files:  $file\n";
    }
    for my $xfile (grep { ! $matched_xfiles{$_} } @{$xfiles_ref}) {
	print "caution: excluded filename not matched_files:  $xfile\n";
    }

    return 1;
}

sub extract_member {
    my ($member, $replace_ref) = @_;

    my $extracted_name = decode_name_of($member);

    # Check existing file or directory
  CHECK:
    while (-e $extracted_name) {
	return if defined ${$replace_ref} && ${$replace_ref} eq 'None';

	return if -d $extracted_name && $member->isDirectory();

	last CHECK if defined ${$replace_ref} && ${$replace_ref} eq 'All';

	my $response = get_response_for($extracted_name);
	if ($response eq 'yes') {
	    last CHECK;
	}
	elsif ($response eq 'no') {
	    return;
	}
	elsif ($response eq 'All') {
	    ${$replace_ref} = 'All';
	    last CHECK;
	}
	elsif ($response eq 'None') {
	    ${$replace_ref} = 'None';
	    return;
	}
	elsif ($response eq 'rename') {
	    $extracted_name = get_new_name();
	    next CHECK;
	}
    }

    print_progress_using($member, $extracted_name);

    $member->extractToFileNamed($extracted_name) == AZ_OK
	or warn "extract error!\n";

    return;
}

sub decode_name_of {
    my ($member) = @_;

    # CP949 -> UTF-8
    my $ENCODING = 'cp949';
    return encode_utf8(decode($ENCODING, $member->fileName()));
}

sub get_response_for {
    my ($extracted_name) = @_;

    my %pattern_for = (
	yes    => qr{^y}xms,
	no     => qr{^n}xms,
	All    => qr{^A}xms,
	None   => qr{^N}xms,
	rename => qr{^r}xms,
    );

  RESPONSE:
    while (1) {
	print "replace $extracted_name? "
	    . "[y]es, [n]o, [A]ll, [N]one, [r]ename: "
		;

	my $response = <STDIN>;
	if (! defined $response) {
	    print qq{\n(EOF or read error, treating as "[N]one" ...)\n};
	    return 'None';
	}

	chomp $response;
	if ($response =~ $pattern_for{yes}) {
	    return 'yes';
	}
	elsif ($response =~ $pattern_for{no}) {
	    return 'no';
	}
	elsif ($response =~ $pattern_for{All}) {
	    return 'All'
	}
	elsif ($response =~ $pattern_for{None}) {
	    return 'None';
	}
	elsif ($response =~ $pattern_for{rename}) {
	    return 'rename';
	}
	else {
	    if ($response eq q{}) {
		warn "error:  invalid response [{ENTER}]\n";
	    }
	    else {
		warn "error:  invalid response [$response]\n";
	    }
	    next RESPONSE;
	}
    }

    return;
}

sub get_new_name {
    my $new_name;

  NAME:
    while (1) {
	print 'new name: ';

	$new_name = <STDIN>;
	next NAME if ! defined $new_name;

	chomp $new_name;
	last NAME if $new_name ne q{};
    }

    return $new_name;
}

sub print_progress_using {
    my ($member, $extracted_name) = @_;

    if ($member->isDirectory()) {
	print "  creating: $extracted_name\n";
    }
    elsif ($member->desiredCompressionMethod() == COMPRESSION_STORED) {
	print " extracting: $extracted_name\n";
    }
    else {
	print "  inflating: $extracted_name\n";
    }

    return;
}

__END__

=head1 NAME

unzip-k - extract a ZIP archive containing file or directory name
encoded in Microsoft's CP949


=head1 SYNOPSIS

B<unzip-k> F<file>[F<.zip>] [F<file(s)>] [-x F<xfile(s)> ...]


=head1 DESCRIPTION

I<unzip-k> will extract compressed files from a ZIP archive containing
file or directory name encoded in Microsoft's CP949. The default
behavior (with no options) is to extract into the current directory
(and subdirectories below it) all files from the specified ZIP
archive.  A companion program, zip(1), creates ZIP archives; both
programs are compatible with archives created by PKWARE's PKZIP and
PKUNZIP for MS-DOS, but in many cases the program options or default
behaviors differ.


=head1 ARGUMENTS

=over

=item F<file>[F<.zip>]

Path of the ZIP archive.

=item [F<file(s)>]

An optional list of archive members to be processed, separated by
spaces.  Regular expressions (wildcards) may be used to match multiple
members.  Be sure to quote expressions that would otherwise be
expanded or modified by the operating system.

=item [-x F<file(s)>]

An optional list of archive members to be excluded from processing.
Since wildcard characters normally match (`/') directory separators,
this option may be used to exclude any files that are in
subdirectories.  For example, ``unzip foo *.[ch] -x */*'' would
extract all C source files in the main directory, but none in any
subdirectories.  Without the -x option, all C source files in all
directories within the zipfile would be extracted.

=back


=head1 EXAMPLES

To use unzip to extract all members of the archive letters.zip into
the current directory and subdirectories below it, creating any
subdirectories as necessary:

unzip letters


=head1 DEPENDENCIES

=over

=item C<Archive::Zip>

=item C<Encode>

=item C<Text::Glob>

=item C<Getopt::Long>

=back


=head1 URL

https://github.com/seungwon0/unzip-k


=head1 AUTHOR

Seungwon Jeong E<lt>seungwon0@gmail.comE<gt>


=head1 SEE ALSO

funzip(1), zip(1), unzip(1), zipcloak(1), zipgrep(1), zipinfo(1),
zipnote(1), zipsplit(1)

=cut
