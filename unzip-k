#!/usr/bin/perl
#
# unzip-k - list, test and extract a ZIP archive containing file or
# directory name encoded in Microsoft's CP949
#
# unzip-k will list, test, or extract compressed files from a ZIP
# archive containing file or directory name encoded in Microsoft's
# CP949.
#
# This program requires Archive::Zip, Text::Glob and IO::Prompt
# modules. In Ubuntu, you may need to install libarchive-zip-perl,
# libtext-glob-perl and libio-prompt-perl package.
#
# http://ubuntu.or.kr/viewtopic.php?f=4&t=13970
#
# Seungwon Jeong <seungwon0@gmail.com>
#
# Copyright (C) 2010 by Seungwon Jeong
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <http://www.gnu.org/licenses/>.

use strict;

use warnings;

use Archive::Zip qw( :ERROR_CODES :CONSTANTS );

use Encode;

use Getopt::Long;

use Text::Glob qw( match_glob );

use File::Spec::Functions qw ( catfile splitpath );

use POSIX qw( strftime );

use IO::Prompt;

my @xfiles;

Getopt::Long::Configure('pass_through');
if ( !GetOptions( 'x=s{1,}' => \@xfiles ) ) {
    print_usage();
    exit 1;
}

my $exdir;
my $crt;
my $list;
my $pipe;
my $test;
my $comment_only;
my $case_insensitive;
my $junk_paths;
my $never_overwrite;
my $overwrite;
my $quiet;
my $strict_wildcard_slash;

Getopt::Long::Configure( 'no_pass_through', 'bundling' );
my @args = (
    'd=s' => \$exdir,

    # Options
    'c' => \$crt,
    'l' => \$list,
    'p' => \$pipe,
    't' => \$test,
    'z' => \$comment_only,

    # Modifiers
    'C' => \$case_insensitive,
    'j' => \$junk_paths,
    'n' => \$never_overwrite,
    'o' => \$overwrite,
    'q' => \$quiet,
    'W' => \$strict_wildcard_slash,
);
if ( !GetOptions(@args) ) {
    print_usage();
    exit 1;
}

if ( !$strict_wildcard_slash ) {
    $Text::Glob::strict_wildcard_slash = 0;
}

if ( @ARGV < 1 ) {
    print_usage();
    exit;
}

my ( $file, @files ) = @ARGV;

undef @ARGV;    # For caution's sake

my $arg_ref = {
    files            => \@files,
    xfiles           => \@xfiles,
    exdir            => $exdir,
    crt              => $crt,
    list             => $list,
    pipe             => $pipe,
    test             => $test,
    comment_only     => $comment_only,
    case_insensitive => $case_insensitive,
    junk_paths       => $junk_paths,
    never_overwrite  => $never_overwrite,
    overwrite        => $overwrite,
    quiet            => $quiet,
};

my @archives = glob $file;

my $nr_success = 0;

for my $archive (@archives) {
    if ( extract_archive( $archive, $arg_ref ) ) {
        $nr_success++;
    }

    if ( @archives > 1 ) {
        print "\n";
    }
}

if ($nr_success) {
    if ( $nr_success > 1 ) {
        print "$nr_success archives were successfully processed.\n";
    }

    exit;
}

# Try to append .zip or .ZIP suffix
for my $assumption ( "$file.zip", "$file.ZIP" ) {
    if ( -f $assumption ) {
        extract_archive( $assumption, $arg_ref ) and exit;
    }
}

die "unzip-k:  cannot find or open $file, $file.zip or $file.ZIP.\n";

sub print_usage {
    print <<'END_USAGE';
UnZip-K 0.8 of 19 December 2010, by Seungwon Jeong.

Usage: unzip-k [-opts[modifiers]] file[.zip] [list] [-x xlist] [-d exdir]
  Default action is to extract files in list, except those in xlist, to exdir;
  file[.zip] may be a wildcard.

  -p  extract files to pipe, no messages     -l  list files
  -t  test compressed archive data           -z  display archive comment only
  -x  exclude files that follow (in xlist)   -d  extract files into exdir
modifiers:
  -n  never overwrite existing files         -q  quiet mode
  -o  overwrite files WITHOUT prompting
  -j  junk paths (do not make directories)
  -C  match filenames case-insensitively
Examples:
  unzip-k data1 -x joe   => extract all files except joe from zipfile data1.zip
  unzip-k -p foo | more  => send contents of foo.zip via pipe into program more
END_USAGE
    return;
}

sub extract_archive {
    my ( $archive_name, $arg_ref ) = @_;
    my $files_ref        = $arg_ref->{files};
    my $xfiles_ref       = $arg_ref->{xfiles};
    my $exdir            = $arg_ref->{exdir};
    my $crt              = $arg_ref->{crt};
    my $list             = $arg_ref->{list};
    my $pipe             = $arg_ref->{pipe};
    my $test             = $arg_ref->{test};
    my $comment_only     = $arg_ref->{comment_only};
    my $case_insensitive = $arg_ref->{case_insensitive};
    my $junk_paths       = $arg_ref->{junk_paths};
    my $never_overwrite  = $arg_ref->{never_overwrite};
    my $overwrite        = $arg_ref->{overwrite};
    my $quiet            = $arg_ref->{quiet};

    if ( !$pipe && !$quiet ) {
        print "Archive:  $archive_name\n";
    }

    my $zip = Archive::Zip->new();

    $zip->read($archive_name) == AZ_OK or return;

    my %matched_file;
    my %matched_xfile;

    my $replace;
    if ($never_overwrite) {
        $replace = 'None';
    }
    elsif ($overwrite) {
        $replace = 'All';
    }

    my $total_length = 0;
    my $total_count  = 0;

    my $error_in_archive;

    if ( !$pipe && !$quiet ) {

        # Print archive comment
        my $archive_comment = $zip->zipfileComment();
        if ( $archive_comment ne q{} ) {
            print $archive_comment, "\n";
        }
    }

    return 1 if $comment_only;

    if ($list) {

        # Print list header
        print "  Length      Date    Time    Name\n";
        print "---------  ---------- -----   ----\n";
    }

    $arg_ref = {
        replace    => \$replace,
        exdir      => $exdir,
        crt        => $crt,
        list       => $list,
        pipe       => $pipe,
        test       => $test,
        error      => \$error_in_archive,
        junk_paths => $junk_paths,
    };

MEMBER:
    for my $member ( $zip->members() ) {
        my $member_name = decode_name_of($member);

        if ($junk_paths) {
            if ( $member->isDirectory() ) {
                next MEMBER;
            }
        }

        # Check archive members to be excluded from processing
        if ( @{$xfiles_ref} ) {
            for my $xfile ( @{$xfiles_ref} ) {
                if (match_glob( $xfile, $member_name )
                    || ( $case_insensitive
                        && match_glob( lc $xfile, lc $member_name ) )
                    )
                {
                    $matched_xfile{$xfile} = 1;

                    next MEMBER;
                }
            }
        }

        if ( @{$files_ref} ) {

            # Check archive members to be processed
            for my $file ( @{$files_ref} ) {
                if (match_glob( $file, $member_name )
                    || ( $case_insensitive
                        && match_glob( lc $file, lc $member_name ) )
                    )
                {
                    $matched_file{$file} = 1;

                    $total_length += $member->uncompressedSize();
                    $total_count++;
                    extract_member( $member, $arg_ref );
                }
            }
        }
        else {
            $total_length += $member->uncompressedSize();
            $total_count++;
            extract_member( $member, $arg_ref );
        }
    }

    if ($list) {

        # Print list footer
        print "---------                     -------\n";
        my $format = "%9u                     %u %s\n";
        printf $format,
            $total_length, $total_count,
            $total_count == 1 ? "file" : "files";
    }

    # print caution about unmatched filenames
    for my $file ( grep { !$matched_file{$_} } @{$files_ref} ) {
        print "caution: filename not matched:  $file\n";
    }
    for my $xfile ( grep { !$matched_xfile{$_} } @{$xfiles_ref} ) {
        print "caution: excluded filename not matched:  $xfile\n";
    }

    if ($test) {
        if ($error_in_archive) {
            print "At least one error was detected in $archive_name.\n";
        }
        elsif ( $total_count == 0 ) {
            print "Caution:  zero files tested in $archive_name.\n";
        }
        elsif ( @{$files_ref} || @{$xfiles_ref} ) {
            print "No errors detected in $archive_name"
                . " for the $total_count files tested.\n";
        }
        else {
            print "No errors detected in compressed data of $archive_name.\n";
        }
    }

    return 1;
}

sub extract_member {
    my ( $member, $arg_ref ) = @_;
    my $replace_ref = $arg_ref->{replace};
    my $exdir       = $arg_ref->{exdir};
    my $crt         = $arg_ref->{crt};
    my $list        = $arg_ref->{list};
    my $pipe        = $arg_ref->{pipe};
    my $test        = $arg_ref->{test};
    my $error_ref   = $arg_ref->{error};
    my $junk_paths  = $arg_ref->{junk_paths};

    # Get file name to be extracted
    my $extracted_name = decode_name_of($member);
    if ( !$crt && !$list && !$pipe && !$test ) {
        if ($junk_paths) {

            # Remove directory portion
            $extracted_name = ( splitpath($extracted_name) )[2];
        }

        if ( defined $exdir && $exdir ne q{} ) {
            $extracted_name = catfile( $exdir, $extracted_name );
        }
    }

    # Check existing file or directory
CHECK:
    while ( !$crt && !$list && !$pipe && !$test && -e $extracted_name ) {
        return if defined ${$replace_ref} && ${$replace_ref} eq 'None';

        return if -d $extracted_name && $member->isDirectory();

        last CHECK if defined ${$replace_ref} && ${$replace_ref} eq 'All';

        my $response = get_response_for($extracted_name);
        if ( $response eq 'yes' ) {
            last CHECK;
        }
        elsif ( $response eq 'no' ) {
            return;
        }
        elsif ( $response eq 'All' ) {
            ${$replace_ref} = 'All';
            last CHECK;
        }
        elsif ( $response eq 'None' ) {
            ${$replace_ref} = 'None';
            return;
        }
        elsif ( $response eq 'rename' ) {
            $extracted_name = get_new_name();
        }
        else {
            warn "invalid response!\n";
        }
    }

    if ( !$list && !$pipe && !$test && !$quiet ) {
        print_progress_using( $member, $extracted_name );
    }

    if ($crt) {
        my ( $contents, $status ) = $member->contents();
        if ( $status == AZ_OK ) {
            $member->extractToFileHandle(*STDOUT);
            if ( !$quiet ) {
                print "\n";
            }
        }
        else {
            warn "extract error!\n";
        }
    }
    elsif ($list) {

        # Print list contents
        my $format = "%9u  %s   %s\n";
        printf $format,
            $member->uncompressedSize(),
            strftime( "%F %R", localtime $member->lastModTime() ),
            $extracted_name;

        if ( !$quiet ) {

            # Print individual file comment
            my $file_comment = $member->fileComment();
            if ( $file_comment ne q{} ) {
                print $file_comment, "\n";
            }
        }
    }
    elsif ($pipe) {
        $member->extractToFileHandle(*STDOUT);
    }
    elsif ($test) {
        if ( !$quiet ) {
            printf "    testing: %-22s", $extracted_name;
            my $diff
                = length($extracted_name) - length( $member->fileName() );
            if ( $diff > 0 ) {
                print q{ } x $diff;
            }
        }

        my $crc32 = $member->crc32();
        my $computed_crc32
            = Archive::Zip::computeCRC32( $member->contents() );
        if ( $crc32 == $computed_crc32 ) {
            if ( !$quiet ) {
                print "   OK\n";
            }
        }
        else {
            ${$error_ref} = 1;
            if ( !$quiet ) {
                printf " bad CRC %08lx  (should be %08lx)\n",
                    $crc32, $computed_crc32;
            }
        }
    }
    else {
        $member->extractToFileNamed($extracted_name) == AZ_OK
            or warn "extract error!\n";
    }

    return;
}

sub decode_name_of {
    my ($member) = @_;

    # CP949 -> UTF-8
    my $ENCODING = 'cp949';
    return encode_utf8( decode( $ENCODING, $member->fileName() ) );
}

sub get_response_for {
    my ($extracted_name) = @_;

    my %pattern_for = (
        yes    => qr{^y}xms,
        no     => qr{^n}xms,
        All    => qr{^A}xms,
        None   => qr{^N}xms,
        rename => qr{^r}xms,
    );

    my $prompt
        = "replace $extracted_name? [y]es, [n]o, [A]ll, [N]one, [r]ename: ";

    while ( my $response = prompt $prompt, -tty ) {
        if ( $response =~ $pattern_for{yes} ) {
            return 'yes';
        }
        elsif ( $response =~ $pattern_for{no} ) {
            return 'no';
        }
        elsif ( $response =~ $pattern_for{All} ) {
            return 'All';
        }
        elsif ( $response =~ $pattern_for{None} ) {
            return 'None';
        }
        elsif ( $response =~ $pattern_for{rename} ) {
            return 'rename';
        }
        else {
            if ( $response eq q{} ) {
                warn "error:  invalid response [{ENTER}]\n";
            }
            else {
                warn "error:  invalid response [$response]\n";
            }
        }
    }

    print qq{\n(EOF or read error, treating as "[N]one" ...)\n};
    return 'None';
}

sub get_new_name {
    my $prompt = 'new name: ';

    while (1) {
        my $new_name = prompt $prompt, -tty;
        if ( defined $new_name && $new_name ne q{} ) {

            # Warning: $new_name is an object, not a string.
            return "$new_name";
        }
    }
}

sub print_progress_using {
    my ( $member, $extracted_name ) = @_;

    if ( $member->isDirectory() ) {
        print "  creating: $extracted_name\n";
    }
    elsif ( $member->desiredCompressionMethod() == COMPRESSION_STORED ) {
        print " extracting: $extracted_name\n";
    }
    else {
        print "  inflating: $extracted_name\n";
    }

    return;
}

__END__

=head1 NAME

unzip-k - list, test and extract a ZIP archive containing file or
directory name encoded in Microsoft's CP949


=head1 SYNOPSIS

B<unzip-k> [B<-clptz>[B<jnoqCW>]] F<file>[F<.zip>] [F<file(s)>] [-x F<xfile(s)> ...] [-d F<exdir>]


=head1 DESCRIPTION

I<unzip-k> will list, test, or extract compressed files from a ZIP
archive containing file or directory name encoded in Microsoft's
CP949. The default behavior (with no options) is to extract into the
current directory (and subdirectories below it) all files from the
specified ZIP archive.  A companion program, I<zip>(1), creates ZIP
archives; both programs are compatible with archives created by
PKWARE's I<PKZIP> and I<PKUNZIP> for MS-DOS, but in many cases the
program options or default behaviors differ.


=head1 ARGUMENTS

=over

=item F<file>[F<.zip>]

Path of the ZIP archive.  If the file specification is a wildcard,
each matching file is processed in an order determined by the
operating system (or file system).  Wildcard expressions are similar
to those supported in commonly used Unix shells (I<sh>, I<ksh>,
I<csh>) and may contain:

=over

=item B<*>

matches a sequence of 0 or more characters

=item B<?>

matches exactly 1 character

=item B<[...]>

matches any single character found inside the brackets; ranges are
specified by a beginning character, a hyphen, and an ending character.
If an exclamation point or a caret (`!' or `^') follows the left
bracket, then the range of characters within the brackets is
complemented (that is, anything I<except> the characters inside the
brackets is considered a match).  To specify a verbatim left bracket,
the three-character sequence ``[[]'' has to be used.

=back

(Be sure to quote any character that might otherwise be interpreted or
modified by the operating system) If no matches are found, the
specification is assumed to be a literal filename; and if that also
fails, the suffix .zip is appended.

=item [F<file(s)>]

An optional list of archive members to be processed, separated by
spaces.  Regular expressions (wildcards) may be used to match multiple
members.  Be sure to quote expressions that would otherwise be
expanded or modified by the operating system.

=item [-x F<file(s)>]

An optional list of archive members to be excluded from processing.
Since wildcard characters normally match (`/') directory separators
(for exceptions see the option -W), this option may be used to exclude
any files that are in subdirectories.  For example, ``unzip-k foo
*.[ch] -x */*'' would extract all C source files in the main
directory, but none in any subdirectories.  Without the -x option, all
C source files in all directories within the zipfile would be
extracted.

=item [-d F<exdir>]

An optional directory to which to extract files.  By default, all
files and subdirectories are recreated in the current direc‐ tory; the
-d option allows extraction in an arbitrary directory (always assuming
one has permission to write to the directory).  This option need not
appear at the end of the command line; it is also accepted before the
zipfile specification (with the nor‐ mal options), immediately after
the zipfile specification, or between the F<file(s)> and the -x
option.  The option and directory may be concatenated without any
white space between them, but note that this may cause normal shell
behavior to be suppressed.  In particular, ``-d ~'' (tilde) is
expanded by Unix C shells into the name of the user's home directory,
but ``-d~'' is treated as a literal subdirectory ``~'' of the current
direc‐ tory.

=back


=head1 OPTIONS

=over

=item B<-c>

extract files to stdout/screen (``CRT'').  This option is similar to
the -p option except that the name of each file is printed as it is
extracted.  This option is not listed in the unzip-k usage screen.

=item B<-l>

list archive files.  The names, uncompressed file sizes and
modification dates and times of the specified files are printed, along
with totals for all files specified.  In addition, the zipfile comment
and individual file comments (if any) are displayed.

=item B<-p>

extract files to pipe (stdout).  Nothing but the file data is sent to
stdout, and the files are always extracted in binary format, just as
they are stored (no conversions).

=item B<-t>

test archive files.  This option extracts each specified file in
memory and compares the CRC (cyclic redundancy check, an enhanced
checksum) of the expanded file with the original file's stored CRC
value.

=item B<-z>

display only the archive comment.

=back


=head1 MODIFIERS

=over

=item B<-C>

use case-insensitive matching for the selection of archive entries
from the command-line list of extract selection patterns.  unzip-k's
philosophy is ``you get what you ask for''.  Because some file systems
are fully case-sensitive (notably those under the Unix operating
system) and because ZIP archives are portable across platforms,
unzip-k's default behavior is to match both wildcard and literal
filenames case-sensitively.  That is, specifying ``makefile'' on the
command line will only match ``makefile'' in the archive, not
``Makefile'' or ``MAKEFILE'' (and similarly for wildcard
specifications).  Since this does not correspond to the behavior of
many other operating/file systems (for example, OS/2 HPFS, which
preserves mixed case but is not sensitive to it), the -C option may be
used to force all filename matches to be case-insensitive.  In the
example above, all three files would then match ``makefile'' (or
``make*'', or similar).  The -C option affects file specs in both the
normal file list and the excluded-file list (xlist).

Please note that the -C option does neither affect the search for the
zipfile(s) nor the matching of archive entries to existing files on
the extraction path.  On a case-sensitive file system, unzip-k will
never try to overwrite a file ``FOO'' when extracting an entry
``foo''!

=item B<-j>

junk paths.  The archive's directory structure is not recreated; all
files are deposited in the extraction directory (by default, the
current one).

=item B<-n>

never overwrite existing files.  If a file already exists, skip the
extraction of that file without prompting.  By default I<unzip-k>
queries before extracting any file that already exists; the user may
choose to overwrite only the current file, overwrite all files, skip
extraction of the current file, skip extraction of all existing files,
or rename the current file.

=item B<-o>

overwrite existing files without prompting.  This is a dangerous
option, so use it with care.

=item B<-q>

perform operations quietly.  Ordinarily I<unzip-k> prints the names of
the files it's extracting or testing, the extraction methods, any file
or zipfile comments that may be stored in the archive, and possibly a
summary when finished with each archive.  The -q options suppress the
printing of some or all of these messages.

=item B<-W>

modifies the pattern matching routine so that both `?' (single-char
wildcard) and `*' (multi-char wildcard) do not match the directory
separator character `/'.  Examples:

"*.c" matches "foo.c" but not "mydir/foo.c"
"*/*.c" matches "bar/foo.c" but not "baz/bar/foo.c"
"??*/*" matches "ab/foo" and "abc/foo" but not "a/foo" or "a/b/foo"

=back


=head1 EXAMPLES

To use I<unzip-k> to extract all members of the archive F<letters.zip>
into the current directory and subdirectories below it, creating any
subdirectories as necessary:

unzip-k letters

To extract all members of F<letters.zip> into the current directory
only:

unzip-k -j letters

To test F<letters.zip>, printing only a summary message indicating
whether the archive is OK or not:

unzip-k -tq letters

To extract the binary file F<paper1.dvi> to standard output and pipe
it to a printing program:

unzip-k -p articles paper1.dvi | dvips

To extract all FORTRAN and C source files--*.f, *.c, *.h, and
Makefile--into the /tmp directory:

unzip-k source.zip "*.[fch]" Makefile -d /tmp

(the double quotes are necessary only in Unix and only if globbing is
turned on).  To extract all FORTRAN and C source files, regardless of
case (e.g., both *.c and *.C, and any makefile, Makefile, MAKEFILE or
similar):

unzip-k -C source.zip "*.[fch]" makefile -d /tmp


=head1 DEPENDENCIES

=over

=item C<Archive::Zip>

=item C<Encode>

=item C<Text::Glob>

=item C<Getopt::Long>

=item C<File::Spec::Functions>

=item C<POSIX>

=item C<IO::Prompt>

=back


=head1 URL

L<https://github.com/seungwon0/unzip-k>


=head1 AUTHOR

Seungwon Jeong E<lt>seungwon0@gmail.comE<gt>


=head1 SEE ALSO

funzip(1), zip(1), unzip(1), zipcloak(1), zipgrep(1), zipinfo(1),
zipnote(1), zipsplit(1)

=cut
